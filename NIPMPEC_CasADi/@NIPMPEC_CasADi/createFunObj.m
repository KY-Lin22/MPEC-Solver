function FunObj = createFunObj(self)
%UNTITLED15 Summary of this function goes here
%   Detailed explanation goes here

import casadi.*
%% function evaluation
FunObj.K = Function('K',...
    {self.MPEC.x, self.MPEC.p}, {self.MPEC.K},...
    {'x', 'p'}, {'K'});

FunObj.L = Function('L',...
    {self.MPEC.x, self.MPEC.p, self.MPEC.w}, {self.MPEC.L},...
    {'x', 'p', 'w'}, {'L'});
FunObj.G = Function('G',...
    {self.MPEC.x, self.MPEC.p, self.MPEC.w}, {self.MPEC.G},...
    {'x', 'p', 'w'}, {'G'});
FunObj.C = Function('C',...
    {self.MPEC.x, self.MPEC.p, self.MPEC.w}, {self.MPEC.C},...
    {'x', 'p', 'w'}, {'C'});
FunObj.PHI = Function('PHI',...
    {self.MPEC.x, self.MPEC.p, self.MPEC.w, self.MPEC.s}, {self.MPEC.PHI},...
    {'x', 'p', 'w', 's'}, {'PHI'});

%% Jacobian evaluation
Lx = jacobian(self.MPEC.L, self.MPEC.x);
Lp = jacobian(self.MPEC.L, self.MPEC.p);
Lw = jacobian(self.MPEC.L, self.MPEC.w);
FunObj.L_grad = Function('L_grad',...
    {self.MPEC.x, self.MPEC.p, self.MPEC.w},{Lx, Lp, Lw},...
    {'x', 'p', 'w'},{'Lx', 'Lp', 'Lw'});

Gx = jacobian(self.MPEC.G, self.MPEC.x);
Gp = jacobian(self.MPEC.G, self.MPEC.p);
Gw = jacobian(self.MPEC.G, self.MPEC.w);
FunObj.G_grad = Function('G_grad',...
    {self.MPEC.x, self.MPEC.p, self.MPEC.w},{Gx, Gp, Gw},...
    {'x', 'p', 'w'},{'Gx', 'Gp', 'Gw'});

Cx = jacobian(self.MPEC.C, self.MPEC.x);
Cp = jacobian(self.MPEC.C, self.MPEC.p);
Cw = jacobian(self.MPEC.C, self.MPEC.w);
FunObj.C_grad = Function('C_grad',...
    {self.MPEC.x, self.MPEC.p, self.MPEC.w},{Cx, Cp, Cw},...
    {'x', 'p', 'w'},{'Cx', 'Cp', 'Cw'});

PHIx = jacobian(self.MPEC.PHI, self.MPEC.x);
PHIp = jacobian(self.MPEC.PHI, self.MPEC.p);
PHIw = jacobian(self.MPEC.PHI, self.MPEC.w);
FunObj.PHI_grad = Function('PHI_grad',...
    {self.MPEC.x, self.MPEC.p, self.MPEC.w, self.MPEC.s},{PHIx, PHIp, PHIw},...
    {'x', 'p', 'w', 's'},{'PHIx', 'PHIp', 'PHIw'});

%% Hessian evaluation
% Lagrangian Hessian
LAG = self.MPEC.L - self.MPEC.sigma' * self.MPEC.G ...
    + self.MPEC.eta' * self.MPEC.C ...
    - self.MPEC.gamma' * self.MPEC.PHI;
[LAG_hessian, ~] = hessian(LAG, [self.MPEC.x; self.MPEC.p; self.MPEC.w]);
FunObj.LAG_hessian = Function('LAG_hessian',...
    {self.MPEC.x, self.MPEC.p, self.MPEC.w, self.MPEC.sigma, self.MPEC.eta, self.MPEC.gamma, self.MPEC.s},...
    {LAG_hessian},...
    {'x', 'p', 'w', 'sigma', 'eta', 'gamma', 's'},...
    {'LAG_hessian'});
% cost function Hessian
[L_hessian, ~] = hessian(self.MPEC.L, [self.MPEC.x; self.MPEC.p; self.MPEC.w]);
FunObj.L_hessian = Function('L_hessian',...
    {self.MPEC.x, self.MPEC.p, self.MPEC.w},...
    {L_hessian},...
    {'x', 'p', 'w'},...
    {'L_hessian'});

%% FB function and Jacobian
% basic FB function and Jacobian
a = SX.sym('a', 1, 1); % dual variable
b = SX.sym('b', 1, 1); % inequality
sqrt_abz = sqrt(a^2 + b^2 + self.MPEC.z^2);
PSI = sqrt_abz - a - b;
PSIa = a/sqrt_abz - 1;
PSIb = b/sqrt_abz - 1;
FB = Function('FB', {a, b, self.MPEC.z}, {PSI}, {'dualVar', 'ineq', 'z'}, {'PSI'});
FB_grad = Function('FB_grad', {a, b, self.MPEC.z}, {PSIa, PSIb}, {'dualVar', 'ineq', 'z'}, {'PSIdualvar', 'PSIineq'});

% FB function for G
G = SX.sym('G', self.MPEC.Dim.sigma, 1);
PSIg = SX.sym('PSIg', self.MPEC.Dim.sigma, 1);
PSIgSigma_diagVec = SX.sym('PSIgSigma_diagVec', self.MPEC.Dim.sigma, 1);% diagonal elements vector of PSIgSigma
PSIgG_diagVec = SX.sym('PSIgG_diagVec', self.MPEC.Dim.sigma, 1);% diagonal elements vector of PSIgG
for i = 1 : self.MPEC.Dim.sigma
    PSIg(i, 1) = FB(self.MPEC.sigma(i, 1), G(i, 1), self.MPEC.z);
    [PSIgSigma_diagVec(i, 1), PSIgG_diagVec(i, 1)] = FB_grad(self.MPEC.sigma(i, 1), G(i, 1), self.MPEC.z);
end
FunObj.FB_G = Function('FB_G',...
    {self.MPEC.sigma, G, self.MPEC.z}, {PSIg},...
    {'sigma', 'G', 'z'}, {'PSIg'});
FunObj.FB_G_grad = Function('FB_G_grad',...
    {self.MPEC.sigma, G, self.MPEC.z}, {PSIgSigma_diagVec, PSIgG_diagVec},...
    {'sigma', 'G', 'z'}, {'PSIgSigma_diagVec', 'PSIgG_diagVec'});

% FB function for PHI
PHI = SX.sym('PHI', self.MPEC.Dim.gamma, 1);
PSIphi = SX.sym('PSIphi', self.MPEC.Dim.gamma, 1);
PSIphiGamma_diagVec = SX.sym('PSIphiGamma_diagVec', self.MPEC.Dim.gamma, 1);% diagonal elements vector of PSIphiGamma
PSIphiPHI_diagVec = SX.sym('PSIphiPHI_diagVec', self.MPEC.Dim.gamma, 1);% diagonal elements vector of PSIphiPHI
for i = 1 : self.MPEC.Dim.gamma
    PSIphi(i, 1) = FB(self.MPEC.gamma(i, 1), PHI(i, 1), self.MPEC.z);
    [PSIphiGamma_diagVec(i, 1), PSIphiPHI_diagVec(i, 1)] = FB_grad(self.MPEC.gamma(i, 1), PHI(i, 1), self.MPEC.z);
end
FunObj.FB_PHI = Function('FB_PHI',...
    {self.MPEC.gamma, PHI, self.MPEC.z}, {PSIphi},...
    {'gamma', 'PHI', 'z'}, {'PSIphi'});
FunObj.FB_PHI_grad = Function('FB_PHI_grad',...
    {self.MPEC.gamma, PHI, self.MPEC.z}, {PSIphiGamma_diagVec, PSIphiPHI_diagVec},...
    {'gamma', 'PHI', 'z'}, {'PSIphiGamma_diagVec', 'PSIphiPHI_diagVec'});

%% Feasibility Restoration Phase
% cost function
FunObj.FRP_L = Function('FRP_L',...
    {self.MPEC.x, self.MPEC.p, self.MPEC.w, self.MPEC.ZRef, self.MPEC.ZWeight},...
    {self.MPEC.FRP_L},...
    {'x', 'p', 'w', 'ZRef', 'ZWeight'},...
    {'FRP_L'});

% Jacobian
FRP_Lx = jacobian(self.MPEC.FRP_L, self.MPEC.x);
FRP_Lp = jacobian(self.MPEC.FRP_L, self.MPEC.p);
FRP_Lw = jacobian(self.MPEC.FRP_L, self.MPEC.w);

FunObj.FRP_L_grad = Function('FRP_L_grad',...
    {self.MPEC.x, self.MPEC.p, self.MPEC.w, self.MPEC.ZRef, self.MPEC.ZWeight},...
    {FRP_Lx, FRP_Lp, FRP_Lw},...
    {'x', 'p', 'w', 'ZRef', 'ZWeight'},...
    {'FRP_Lx', 'FRP_Lp', 'FRP_Lw'});

% Hessian
[FRP_L_hessian, ~] = hessian(self.MPEC.FRP_L, [self.MPEC.x; self.MPEC.p; self.MPEC.w]);
FunObj.FRP_L_hessian = Function('FRP_L_hessian',...
    {self.MPEC.x, self.MPEC.p, self.MPEC.w, self.MPEC.ZRef, self.MPEC.ZWeight},...
    {FRP_L_hessian},...
    {'x', 'p', 'w', 'ZRef', 'ZWeight'},...
    {'FRP_L_hessian'});
end

