function FunObj = createFunObj(self)
%UNTITLED15 Summary of this function goes here
%   Detailed explanation goes here

import casadi.*
MPEC = self.MPEC;
Dim = MPEC.Dim;

%% symbolic variable
sigma = SX.sym('sigma', Dim.sigma, 1); % dual variable for G
eta = SX.sym('eta', Dim.eta, 1); % dual variable for C
gamma = SX.sym('gamma', Dim.gamma, 1); % dual variable for PHI

%% function evaluation
FunObj.K = Function('K',...
    {MPEC.x, MPEC.p}, {MPEC.K},...
    {'x', 'p'}, {'K'});

FunObj.L = Function('L',...
    {MPEC.x, MPEC.p, MPEC.w}, {MPEC.L},...
    {'x', 'p', 'w'}, {'L'});
FunObj.G = Function('G',...
    {MPEC.x, MPEC.p}, {MPEC.G},...
    {'x', 'p'}, {'G'});
FunObj.C = Function('C',...
    {MPEC.x, MPEC.p, MPEC.w}, {MPEC.C},...
    {'x', 'p', 'w'}, {'C'});
FunObj.PHI = Function('PHI',...
    {MPEC.p, MPEC.w, MPEC.s}, {MPEC.PHI},...
    {'p', 'w', 's'}, {'PHI'});

%% Jacobian evaluation
Lx_formula = jacobian(MPEC.L, MPEC.x);
Lp_formula = jacobian(MPEC.L, MPEC.p);
Lw_formula = jacobian(MPEC.L, MPEC.w);
FunObj.L_grad = Function('L_grad',...
    {MPEC.x, MPEC.p, MPEC.w},{Lx_formula, Lp_formula, Lw_formula},...
    {'x', 'p', 'w'},{'Lx', 'Lp', 'Lw'});

Gx_formula = jacobian(MPEC.G, MPEC.x);
Gp_formula = jacobian(MPEC.G, MPEC.p);
FunObj.G_grad = Function('G_grad',...
    {MPEC.x, MPEC.p},{Gx_formula, Gp_formula},...
    {'x', 'p'},{'Gx', 'Gp'});

Cx_formula = jacobian(MPEC.C, MPEC.x);
Cp_formula = jacobian(MPEC.C, MPEC.p);
Cw_formula = jacobian(MPEC.C, MPEC.w);
FunObj.C_grad = Function('C_grad',...
    {MPEC.x, MPEC.p, MPEC.w},{Cx_formula, Cp_formula, Cw_formula},...
    {'x', 'p', 'w'},{'Cx', 'Cp', 'Cw'});

PHIp_formula = jacobian(MPEC.PHI, MPEC.p);
PHIw_formula = jacobian(MPEC.PHI, MPEC.w);
FunObj.PHI_grad = Function('PHI_grad',...
    {MPEC.p, MPEC.w, MPEC.s},{PHIp_formula, PHIw_formula},...
    {'p', 'w', 's'},{'PHIp', 'PHIw'});

%% Hessian evaluation
% Lagrangian Hessian
LAG_formula = MPEC.L - sigma' * MPEC.G + eta' * MPEC.C - gamma' * MPEC.PHI;
[LAG_hessian_formula, ~] = hessian(LAG_formula, [MPEC.x; MPEC.p; MPEC.w]);
FunObj.LAG_hessian = Function('LAG_hessian',...
    {MPEC.x, MPEC.p, MPEC.w, sigma, eta, gamma, MPEC.s},...
    {LAG_hessian_formula},...
    {'x', 'p', 'w', 'sigma', 'eta', 'gamma', 's'},...
    {'LAG_hessian'});
% cost function Hessian
[L_hessian_formula, ~] = hessian(MPEC.L, [MPEC.x; MPEC.p; MPEC.w]);
FunObj.L_hessian = Function('L_hessian',...
    {MPEC.x, MPEC.p, MPEC.w},...
    {L_hessian_formula},...
    {'x', 'p', 'w'},...
    {'L_hessian'});

%% FB function and Jacobian
% basic FB function and Jacobian
a = SX.sym('a', 1, 1); % dual variable
b = SX.sym('b', 1, 1); % inequality
sqrt_abz = sqrt(a^2 + b^2 + MPEC.z^2);
PSI = sqrt_abz - a - b;
PSIa = a/sqrt_abz - 1;
PSIb = b/sqrt_abz - 1;
FB = Function('FB', {a, b, MPEC.z}, {PSI}, {'a', 'b', 'z'}, {'PSI'});
FB_grad = Function('FB_grad',{a, b, MPEC.z}, {PSIa, PSIb}, {'a', 'b', 'z'}, {'PSIa', 'PSIb'});

% FB function for G
G = SX.sym('G', Dim.sigma, 1);
PSIg_formula = SX.sym('PSIg_formula', Dim.sigma, 1);
PSIgSigma_diagVec_formula = SX.sym('PSIgSigma_diagVec_formula', Dim.sigma, 1);% diagonal elements vector of PSIgSigma
PSIgG_diagVec_formula = SX.sym('PSIgG_diagVec_formula', Dim.sigma, 1);% diagonal elements vector of PSIgG
for i = 1 : Dim.sigma
    PSIg_formula(i, 1) = FB(sigma(i, 1), G(i, 1), MPEC.z);
    [PSIgSigma_diagVec_formula(i, 1), PSIgG_diagVec_formula(i, 1)] = FB_grad(sigma(i, 1), G(i, 1), MPEC.z);
end
FunObj.FB_G = Function('FB_G',...
    {sigma, G, MPEC.z}, {PSIg_formula},...
    {'sigma', 'G', 'z'}, {'PSIg'});
FunObj.FB_G_grad = Function('FB_G_grad',...
    {sigma, G, MPEC.z}, {PSIgSigma_diagVec_formula, PSIgG_diagVec_formula},...
    {'sigma', 'G', 'z'}, {'PSIgSigma_diagVec', 'PSIgG_diagVec'});

% FB function for PHI
PHI = SX.sym('PHI', Dim.gamma, 1);
PSIphi_formula = SX.sym('PSIphi_formula', Dim.gamma, 1);
PSIphiGamma_diagVec_formula = SX.sym('PSIphiGamma_diagVec_formula', Dim.gamma, 1);% diagonal elements vector of PSIphiGamma
PSIphiPHI_diagVec_formula = SX.sym('PSIphiPHI_diagVec_formula', Dim.gamma, 1);% diagonal elements vector of PSIphiPHI
for i = 1 : Dim.gamma
    PSIphi_formula(i, 1) = FB(gamma(i, 1), PHI(i, 1), MPEC.z);
    [PSIphiGamma_diagVec_formula(i, 1), PSIphiPHI_diagVec_formula(i, 1)] = FB_grad(gamma(i, 1), PHI(i, 1), MPEC.z);
end
FunObj.FB_PHI = Function('FB_PHI',...
    {gamma, PHI, MPEC.z}, {PSIphi_formula},...
    {'gamma', 'PHI', 'z'}, {'PSIphi'});
FunObj.FB_PHI_grad = Function('FB_PHI_grad',...
    {gamma, PHI, MPEC.z}, {PSIphiGamma_diagVec_formula, PSIphiPHI_diagVec_formula},...
    {'gamma', 'PHI', 'z'}, {'PSIphiGamma_diagVec', 'PSIphiPHI_diagVec'});
            
%% Feasibility Restoration Phase
% FRP cost function
ZRef = SX.sym('ZRef', Dim.Z, 1); % reference primal variable in FRP cost function
ZWeight = SX.sym('ZWeight', Dim.Z, 1); % weight matrix in FRP cost function
Z = [MPEC.x; MPEC.p; MPEC.w];
FRP_L = 0.5 * (Z - ZRef)' * diag(ZWeight) * (Z - ZRef);

FunObj.FRP_L = Function('FRP_L',...
    {MPEC.x, MPEC.p, MPEC.w, ZRef, ZWeight},...
    {FRP_L},...
    {'x', 'p', 'w', 'ZRef', 'ZWeight'},...
    {'FRP_L'});

% Jacobian
FRP_Lx = jacobian(FRP_L, MPEC.x);
FRP_Lp = jacobian(FRP_L, MPEC.p);
FRP_Lw = jacobian(FRP_L, MPEC.w);

FunObj.FRP_L_grad = Function('FRP_L_grad',...
    {MPEC.x, MPEC.p, MPEC.w, ZRef, ZWeight},...
    {FRP_Lx, FRP_Lp, FRP_Lw},...
    {'x', 'p', 'w', 'ZRef', 'ZWeight'},...
    {'FRP_Lx', 'FRP_Lp', 'FRP_Lw'});

% Hessian
[FRP_L_hessian, ~] = hessian(FRP_L, [MPEC.x; MPEC.p; MPEC.w]);
FunObj.FRP_L_hessian = Function('FRP_L_hessian',...
    {MPEC.x, MPEC.p, MPEC.w, ZRef, ZWeight},...
    {FRP_L_hessian},...
    {'x', 'p', 'w', 'ZRef', 'ZWeight'},...
    {'FRP_L_hessian'});
end

